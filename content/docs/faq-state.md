---
id: faq-state
title: Կոմպոնենտի վիճակ
permalink: docs/faq-state.html
layout: docs
category: FAQ
---

### Ի՞նչ է `setState`-ը անում {#what-does-setstate-do}

`setState()`-ը պլանավորում է կոմպոնենտի `state` օբյեկտի թարմացում։ state-ի թարմացումից հետո կոմպոնենտը արտապատկերվում է։

### Ի՞նչ տարբերություն կա `state`-ի և `props`-ի միջև {#what-is-the-difference-between-state-and-props}

[`props`](/docs/components-and-props.html)-ը («properties»-ի կրճատ տարբերակը) և [`state`](/docs/state-and-lifecycle.html)-ը պարզ օբյեկտներ են։ Չնայած երկուսն էլ պահում են ինֆորմացիա\` որը ազդում է արտապատկերման վրա, դրանք ունեն մեկ կարևոր տարբերություն. `props`-ը *փոխանցվում է* կոմպոնենտին (ինչպես ֆունկցիայի պարամետրերը),  մինչդեռ `state`-ը *տեղակայված է* կոմպոնենտի ներսում (ինչպես փոփոխականները հայտարարվում են ֆունկցիայի ներսում)։

Ահա մի քանի օգտակար ռեսուրսներ լրացուցիչ ընթերցման համար, թե երբ օգտագործել `props` և երբ `state`։
* [Props, թե State](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)<sub>eng</sub>
* [ReactJS: Props, թե State](https://lucybain.com/blog/2016/react-state-vs-pros/)<sub>eng</sub>

### Ի՞նչու է `setState`-ը վերադարձնում սխալ արժեք {#why-is-setstate-giving-me-the-wrong-value}

React-ում `this.props`-ը և `this.state`-ը ներկայացնում են *արտապատկերված* արժեքներ, այսինքն\` այն ինչ տվյալ պահին երևում է էկրանին։

`setState`-ի կանչերը անսինխրոն են - `setState` կանչելուց հետո, երբ ուզում եք անմիջապես արտացոլել նոր արժեքը\` հույս մի դրեք `this.state`-ի վրա։ Եթե ուզում եք հաշվարկել արժեքները հիմնվելով ընթացիք state-ի վրա, օբյեկտի փոխարեն `setState`-ին փոխանցեք թարմացնող ֆունկցիա։ (ստորև ներկայացված է մանրամասն օրինակ)։

Կոդի օրինակ\` որը *չի* աշխատի այնպես, ինչպես ակնկալվում է.

```jsx
incrementCount() {
  // Նշում. սա *չի* աշխատի նախատեսվածին պես։
  this.setState({count: this.state.count + 1});
}

handleSomething() {
  // Պատկերացնենք `this.state.count`-ը սկսվում է 0-ից։
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();
  // Երբ React-ը արտապատկերի կոմպոնենտը `this.state.count`-ի արժեքը կլինի 1, չնայած ակնկալում ենք 3:

  // Պատճառը կայանում է նրանում, որ վերոնշյալ `incrementCount()`-ը վերցնում է `this.state.count`-ը,
  // բայց React-ը չի թարմացնում `this.state.count`-ը, մինչև կոմպոնենտի արտապատկերումը։
  // Այսինքն `incrementCount()`-ը ամեն անգամ ստանում է `this.state.count`-ի արժեքը` որպես 0, և դարձնում 1: 

  // Լուծումը նկարագրված է ստորև
}
```

Ստորև ներկայացված է խնդրի լուծումը։

### Ինպե՞ս կարող եմ թարմացնել state-ը, օգտագործելով արժեքներ\` որոնք կախված են ընթացիք state-ից {#how-do-i-update-state-with-values-that-depend-on-the-current-state}

Օբյեկտի փոխարեն, `setState`-ին փոխանցեք ֆունկցիա, համոզված լինելու համար, որ ֆունկցիայի կանչը միշտ օգտագործում է state-ի վերջին թարմացված տարբերակը (օրինակը\` ստորև)։ 

### Ի՞նչ տարբերություն կա `setState`-ին օբյեկտ կամ ֆունկցիա փոխանցելու միջև {#what-is-the-difference-between-passing-an-object-or-a-function-in-setstate}

Երբ մենք փոխանցում ենք թարմացնող ֆունկցիա, դա մեզ թույլ է տալիս դրա ներսում ունենալ ընթացիկ state-ի արժեքը։ Քանի որ `setState`-ի կանչերը խմբավորված էն, դա թույլ է տալիս ունենալ շղթայական թարմացումներ, և ապահովում է, որ առանց հակասությունների դրանք կատարվեն հաջորդականությամբ.

```jsx
incrementCount() {
  this.setState((state) => {
    // Կարևոր է. թարմացման ժամանակ, `this.state`-ի փոխարեն օգտագործեք `state`։
    return {count: state.count + 1}
  });
}

handleSomething() {
  // Պատկերացնենք `this.state.count`-ը սկսվում է 0-ից։
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();

  // Եթե օգտագործեք `this.state.count`-ը` հիմա, դրա արժեքը դեռևս 0 կլինի։
  // Սակայն, երբ React-ը արտապատկերի կոմպոնենտը` արժեքը կլինի 3:
}
```

[Կարդացեք ավելին setState-ի մասին](/docs/react-component.html#setstate)

### Ե՞րբ է `setState`-ը անսինխրոն {#when-is-setstate-asynchronous}

Ներկայումս `setState`-ը իրադարձության մշակողների ներսում աշխատում է անսինխրոն կերպով։

Սա երաշխավորում է, որ օրինակ, երբ և’ `Parent`-ը և’ `Child`-ը կանչեն `setState` սեղմման իրադարձության ժամանակ, `Child`-ը երկու անգամ չվերա-արտապատկերվի։ Փոխարենը, React-ը «հետաձգում» է state-ի թարմացումները մինչ զննարկչի իրադարձության ավարտը։ Այս արդյունքը էական է արտադրողականության բարելավումների տեսանկյունից\` խոշոր ծրագրերում։

Սա իրականացման ընդամենը մի մասն է, հետեւաբար անմիջապես մի վստահեք դրան: React-ի հետագա տարբերակներում state-ի թարմացումները խմբավորված կլինեն լռելյայնորեն։

### Ի՞նչու React-ը չի թարմացնում `this.state`-ը համաժամանակյա կերպով {#why-doesnt-react-update-thisstate-synchronously}

Ինչպես ասվում է վերը նշվածում, մինչև, որ կսկսի վերա-արտապատկերումը, React-ը դիտավորյալ «սպասում է» մինչև բոլոր կոմպոնենտները իրենց իրադարձության մշակողի ներսում կանչեն `setState()`։ Դա խթանում է արտադրողականությանը\` խուսափելով ավելորդ վերա-արտապատկերումներից։

Ամեն դեպքում, գուցե դեռ զարմացած եք, թե ինչի React-ը ուղղակի անմիջապես չի թարմացնում `this.state`-ը, առանց արտապատկերման։

Այստեղ երկու հիմնական պատճառ կա.

* Սա կխախտի `props`-ի և `state`-ի աշխատանքի տրամաբանությունը, կհանգեցնի չափազանց դժվար կարգաբերելի խնդրի։
* Սա անհնար կդարձնի ինտեգրել մի շարք նոր գործառույթներ, որոնք այս պահին աշխատանքային փուլում են։ 

Այս [GitHub-ի մեկնաբանությունը](https://github.com/facebook/react/issues/11527#issuecomment-360199710) հաշվի է առնում ավելի կոնկրետ օրինակներ, որոնք կօգնեն ավելի խորը ուսումնասիրելուն։։

### Արդյո՞ք պետք է օգտագործեմ վիճակի կառավարման գրադարան ինչպիսիք են Redux-ը կամ MobX-ը {#should-i-use-a-state-management-library-like-redux-or-mobx}

[Միգուցե։](https://redux.js.org/faq/general#when-should-i-use-redux)<sub>eng</sub>

Լավ գաղափար է սկզբից սովորել React, մինչև հավելյալ գրադարաններ ավելացնելը։ Դուք կարող եք կառուցել բավականին համալիր հավելվածներ օգտագործելով միայն React։
